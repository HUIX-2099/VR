<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="theme-color" content="#202225">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>PlayCanvas VR Demo</title>
    <style>
      html, body { height: 100%; margin: 0; background: #202225; color: #e6e6e6; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
      #app { width: 100%; height: 100%; position: relative; overflow: hidden; display: none; }
      /* VR button now lives inside #panel and uses panel button styles */
      #note { position: absolute; right: 16px; bottom: 16px; opacity: .8; font-size: 12px; max-width: 320px; text-align: right; }
      #panel { position: absolute; top: 12px; left: 12px; background: rgba(0,0,0,.45); backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,.08); padding: 10px; border-radius: 10px; display: none; gap: 8px; width: 320px; }
      #panel .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      #panel button, #panel input, #panel label, #panel select { font-size: 12px; }
      #panel button { padding: 6px 8px; border-radius: 6px; border: 1px solid rgba(255,255,255,.15); background: #374151; color: #fff; cursor: pointer; }
      #panel button:hover { background: #4b5563; }
      #panel input[type="color"] { width: 100%; height: 28px; border: none; padding: 0; background: transparent; }
      #panel input[type="range"] { width: 100%; }
      #panel small { opacity: .8; }
      canvas { touch-action: none; }
      /* Daydream-like lens vignette shown in Cardboard */
      #lensMask { position: fixed; inset: 0; pointer-events: none; display: none; z-index: 500; background:
        radial-gradient(circle at 25% 50%, rgba(0,0,0,0) 40%, rgba(0,0,0,0.05) 60%, rgba(0,0,0,0.25) 85%, rgba(0,0,0,0.6) 100%) 0 0/50% 100% no-repeat,
        radial-gradient(circle at 75% 50%, rgba(0,0,0,0) 40%, rgba(0,0,0,0.05) 60%, rgba(0,0,0,0.25) 85%, rgba(0,0,0,0.6) 100%) 0 0/100% 100% no-repeat; }
      #vrFab { position: fixed; right: 16px; bottom: 16px; width: 48px; height: 48px; border-radius: 50%; border: none; background: #4f46e5; color: #fff; font-weight: 700; box-shadow: 0 6px 18px rgba(0,0,0,.25); z-index: 1000; display: none !important; }
      #vrFab[disabled] { opacity: .6; }
    </style>
    <script src="https://code.playcanvas.com/playcanvas-stable.min.js"></script>
    <script src="https://unpkg.com/aframe@1.5.0/dist/aframe.min.js"></script>
  </head>
  <body>
    <div id="app">
      <canvas id="canvas"></canvas>
      <div id="note">Use a WebXR-capable browser (HTTPS or localhost). On desktop, use a headset (OpenXR). On mobile, WebXR is required.</div>
      <div id="panel">
        <div class="row">
          <button id="vrBtn" hidden>Enter VR</button>
        </div>
        <div class="row">
          <button id="btnAmbient">Add Ambient</button>
          <button id="btnDirectional">Add Directional</button>
        </div>
        <div class="row">
          <button id="btnPoint">Add Point</button>
          <button id="btnClearLights">Remove All Lights</button>
        </div>
        <div class="row">
          <label>Light Color</label>
          <input id="lightColor" type="color" value="#ffffff" />
        </div>
        <div class="row">
          <label>Intensity</label>
          <input id="lightIntensity" type="range" min="0" max="4" step="0.1" value="1.2" />
        </div>
        <div class="row">
          <label>Mouse Sens.</label>
          <input id="mouseSens" type="range" min="0.02" max="0.6" step="0.02" value="0.12" />
        </div>
        <div class="row">
          <label><input id="invertY" type="checkbox" /> Invert Y</label>
          <span style="opacity:.8;align-self:center;">Click canvas to look</span>
        </div>
        <hr style="opacity:.2;border:none;border-top:1px solid rgba(255,255,255,.15);">
        <div class="row">
          <label>Lights</label>
          <select id="lightList"></select>
        </div>
        <div class="row">
          <label>X</label>
          <input id="posX" type="range" min="-20" max="20" step="0.1" value="0" />
        </div>
        <div class="row">
          <label>Y</label>
          <input id="posY" type="range" min="0" max="10" step="0.1" value="2" />
        </div>
        <div class="row">
          <label>Z</label>
          <input id="posZ" type="range" min="-20" max="20" step="0.1" value="0" />
        </div>
        <div class="row">
          <button id="btnSave">Save</button>
          <button id="btnLoad">Load</button>
        </div>
        <div class="row">
          <button id="btnExport">Export JSON</button>
          <button id="btnImport">Import JSON</button>
        </div>
        <div class="row">
          <button id="btnCardboard">Enable Cardboard</button>
          <small>Stereo split mode</small>
        </div>
        <input id="importFile" type="file" accept="application/json" style="display:none;" />
      </div>
    </div>
    <button id="vrFab" aria-label="Enter VR" title="Enter VR">VR</button>
    <div id="lensMask"></div>

    <!-- A-Frame scene for VR lenses and look-around -->
    <a-scene id="aframeScene"
             renderer="colorManagement: true"
             vr-mode-ui="enabled: true"
             device-orientation-permission-ui>
      <a-assets>
        <a-asset-item id="museum" src="./museum.glb"></a-asset-item>
      </a-assets>

      <a-entity id="rig" position="0 1.65 4">
        <a-entity id="camera" camera look-controls wasd-controls="acceleration: 40"></a-entity>
      </a-entity>

      <a-entity light="type: directional; intensity: 1.2" position="1 2 1"></a-entity>
      <a-entity gltf-model="#museum" position="0 0 0" scale="1 1 1"></a-entity>

      <a-plane rotation="-90 0 0" width="50" height="50" color="#55CAA6"></a-plane>
      <a-box position="0 1.25 0" color="#AAAAAA"></a-box>
    </a-scene>

    <script>
      (function(){
        const scene = document.getElementById('aframeScene');
        function isMobile(){ return /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent); }
        async function tryEnterVR(){
          try {
            if (navigator.xr && await navigator.xr.isSessionSupported('immersive-vr')) {
              await scene.enterVR(); return true;
            }
            await scene.enterVR(); return true;
          } catch(e){ return false; }
        }
        scene.addEventListener('loaded', async () => {
          if (isMobile()) {
            const ok = await tryEnterVR();
            if (!ok) {
              const once = async () => {
                window.removeEventListener('touchend', once);
                window.removeEventListener('click', once);
                await tryEnterVR();
              };
              window.addEventListener('touchend', once, { once: true });
              window.addEventListener('click', once, { once: true });
            }
          }
        });
      })();
    </script>

    <script>
      (function () {
        const canvas = document.getElementById('canvas');
        const app = new pc.Application(canvas, {
          graphicsDeviceOptions: { antialias: true, xrCompatibility: true }
        });
        app.setCanvasFillMode(pc.FILLMODE_FILL_WINDOW);
        app.setCanvasResolution(pc.RESOLUTION_AUTO);
        function resize() { app.resizeCanvas(); }
        window.addEventListener('resize', resize);

        // Scene
        app.scene.gammaCorrection = pc.GAMMA_SRGB;
        app.scene.toneMapping = pc.TONEMAP_ACES;
        app.scene.skyboxMip = 2;

        // Camera rig (yaw/pitch) for desktop look + move
        const pivotYaw = new pc.Entity('PivotYaw');
        const pivotPitch = new pc.Entity('PivotPitch');
        const camera = new pc.Entity('Camera');
        camera.addComponent('camera', { clearColor: new pc.Color(0.88, 0.93, 1) });
        pivotYaw.addChild(pivotPitch);
        pivotPitch.addChild(camera);
        pivotYaw.setLocalPosition(0, 1.65, 4);
        app.root.addChild(pivotYaw);

        const keys = {};
        let lookX = 0, lookY = 0;
        let targetLookX = 0, targetLookY = 0; // for smoothing
        let lookSensitivity = 0.12;
        let invertY = false;
        let moveSpeed = isMobile() ? 1.6 : 2.5;
        window.addEventListener('keydown', (e) => { keys[e.code] = true; if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') moveSpeed = 4.5; });
        window.addEventListener('keyup', (e) => { keys[e.code] = false; if (!(keys['ShiftLeft'] || keys['ShiftRight'])) moveSpeed = 2.5; });
        canvas.addEventListener('mousedown', () => { if (!app.xr || !app.xr.active) canvas.requestPointerLock?.(); });
        window.addEventListener('mousemove', (e) => {
          if (document.pointerLockElement === canvas && (!app.xr || !app.xr.active)) {
            targetLookY += e.movementX * lookSensitivity;
            targetLookX += (invertY ? e.movementY : -e.movementY) * lookSensitivity;
            if (targetLookX > 89) targetLookX = 89; if (targetLookX < -89) targetLookX = -89;
          }
        });

        // Touch look controls for mobile
        let touchActive = false;
        let lastTouch = null;
        let panActive = false; // two-finger movement
        let lastPan = null;    // average position of two touches
        canvas.addEventListener('touchstart', (e) => {
          if (app.xr && app.xr.active) return;
          if (e.touches.length === 1) {
            const t = e.touches[0];
            if (!t) return;
            touchActive = true;
            lastTouch = { x: t.clientX, y: t.clientY };
          } else if (e.touches.length >= 2) {
            // start two-finger pan for movement
            const ax = (e.touches[0].clientX + e.touches[1].clientX) * 0.5;
            const ay = (e.touches[0].clientY + e.touches[1].clientY) * 0.5;
            panActive = true;
            lastPan = { x: ax, y: ay };
          }
          e.preventDefault();
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
          if (app.xr && app.xr.active) return;
          if (e.touches.length === 1 && touchActive) {
            const t = e.touches[0];
            if (!t || !lastTouch) return;
            const dx = t.clientX - lastTouch.x;
            const dy = t.clientY - lastTouch.y;
            targetLookY += dx * lookSensitivity * 0.5;
            targetLookX += (invertY ? dy : -dy) * lookSensitivity * 0.5;
            if (targetLookX > 89) targetLookX = 89; if (targetLookX < -89) targetLookX = -89;
            lastTouch = { x: t.clientX, y: t.clientY };
          } else if (e.touches.length >= 2) {
            // two-finger pan movement
            const ax = (e.touches[0].clientX + e.touches[1].clientX) * 0.5;
            const ay = (e.touches[0].clientY + e.touches[1].clientY) * 0.5;
            if (!panActive || !lastPan) {
              panActive = true;
              lastPan = { x: ax, y: ay };
            } else {
              const dx = ax - lastPan.x;
              const dy = ay - lastPan.y;
              // Movement sensitivity tuning
              const moveScale = 0.01;
              const forward = pivotYaw.forward.clone(); forward.y = 0; forward.normalize();
              const right = pivotYaw.right.clone(); right.y = 0; right.normalize();
              const move = new pc.Vec3(0,0,0);
              // Vertical drag: forward/back; Horizontal: strafe
              move.add(forward.scale(-dy * moveScale));
              move.add(right.scale(dx * moveScale));
              if (move.lengthSq() > 0) {
                pivotYaw.translate(move);
              }
              lastPan = { x: ax, y: ay };
            }
          }
          e.preventDefault();
        }, { passive: false });
        let lastTapTime = 0;
        canvas.addEventListener('touchend', (ev) => {
          if (event.touches && event.touches.length > 0) return;
          const now = performance.now();
          if (ev.changedTouches && ev.changedTouches.length === 1 && (now - lastTapTime) < 280) {
            baseQuat = null; // double-tap to recenter gyro baseline
          }
          lastTapTime = now;
          touchActive = false; lastTouch = null;
          panActive = false; lastPan = null;
        });

        // Device orientation (gyro) look for mobile when not in XR (quaternion-based)
        let gyroEnabled = false;
        let baseQuat = null; // pc.Quat baseline
        function getScreenOrientationRad() {
          const ang = (screen.orientation && typeof screen.orientation.angle === 'number') ? screen.orientation.angle : (typeof window.orientation === 'number' ? window.orientation : 0);
          return (ang || 0) * Math.PI / 180;
        }
        function quatFromAxisAngle(axis, angleRad) {
          const q = new pc.Quat();
          q.setFromAxisAngle(axis, angleRad * 180 / Math.PI);
          return q;
        }
        function composeDeviceQuat(alphaDeg, betaDeg, gammaDeg, screenRad) {
          // Convert to radians
          const a = (alphaDeg || 0) * Math.PI / 180; // Z
          const b = (betaDeg || 0) * Math.PI / 180;  // X
          const g = (gammaDeg || 0) * Math.PI / 180; // Y
          // Intrinsic ZXY order: q = Rz(a) * Rx(b) * Ry(g)
          const qZ = quatFromAxisAngle(pc.Vec3.FORWARD, a);
          const qX = quatFromAxisAngle(pc.Vec3.RIGHT, b);
          const qY = quatFromAxisAngle(pc.Vec3.UP, g);
          const qZX = new pc.Quat(); qZX.mul2(qZ, qX);
          const q = new pc.Quat(); q.mul2(qZX, qY);
          // Adjust for screen orientation (rotate around Z by -screenRad)
          const qScreen = quatFromAxisAngle(pc.Vec3.FORWARD, -screenRad);
          const out = new pc.Quat(); out.mul2(q, qScreen);
          return out;
        }
        function handleOrientation(ev) {
          if (app.xr && app.xr.active) return;
          if (!gyroEnabled) return;
          const { alpha, beta, gamma } = ev;
          if (alpha == null || beta == null || gamma == null) return;
          const current = composeDeviceQuat(alpha, beta, gamma, getScreenOrientationRad());
          if (!baseQuat) baseQuat = current.clone();
          const invBase = baseQuat.clone(); invBase.invert();
          const rel = new pc.Quat(); rel.mul2(invBase, current);
          const e = rel.getEulerAngles(); // XYZ order
          // Map to yaw (Y) and pitch (X)
          const gyroScale = 1.0;
          targetLookY = e.y * gyroScale;
          targetLookX = pc.math.clamp(e.x * gyroScale, -89, 89);
        }
        async function enableGyroLookIfPossible() {
          if (!(isMobile())) return;
          try {
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
              const perm = await DeviceOrientationEvent.requestPermission().catch(() => 'denied');
              if (perm !== 'granted') return; // fall back to touch
            }
            window.addEventListener('deviceorientation', handleOrientation);
            gyroEnabled = true;
          } catch (_) { /* ignore, fallback to touch */ }
        }

        // UI bindings for look
        const sensSlider = document.getElementById('mouseSens');
        sensSlider.addEventListener('input', () => { lookSensitivity = parseFloat(sensSlider.value); });
        const invertYChk = document.getElementById('invertY');
        invertYChk.addEventListener('change', () => { invertY = invertYChk.checked; });

        // Light
        const light = new pc.Entity('Light');
        light.addComponent('light', { type: 'directional', color: new pc.Color(1,1,1), intensity: 1.2, castShadows: true });
        light.setLocalEulerAngles(45, 35, 0);
        app.root.addChild(light);

        // Light tools
        const createdLights = [];
        const ui = {
          btnAmbient: document.getElementById('btnAmbient'),
          btnDirectional: document.getElementById('btnDirectional'),
          btnPoint: document.getElementById('btnPoint'),
          btnClear: document.getElementById('btnClearLights'),
          color: document.getElementById('lightColor'),
          intensity: document.getElementById('lightIntensity'),
          lightList: document.getElementById('lightList'),
          posX: document.getElementById('posX'),
          posY: document.getElementById('posY'),
          posZ: document.getElementById('posZ'),
          btnSave: document.getElementById('btnSave'),
          btnLoad: document.getElementById('btnLoad'),
          btnExport: document.getElementById('btnExport'),
          btnImport: document.getElementById('btnImport'),
          importFile: document.getElementById('importFile'),
          btnCardboard: document.getElementById('btnCardboard')
        };

        function parseColor(hex) {
          const c = pc.Color.fromString(hex);
          return new pc.Color(c.r, c.g, c.b);
        }

        function addAmbient() {
          const e = new pc.Entity('AmbientLight');
          e.addComponent('light', {
            type: 'ambient',
            color: parseColor(ui.color.value),
            intensity: parseFloat(ui.intensity.value)
          });
          app.root.addChild(e);
          createdLights.push(e);
          refreshLightList();
          saveStateDebounced();
        }

        function addDirectional() {
          const e = new pc.Entity('DirectionalLight');
          e.addComponent('light', {
            type: 'directional',
            color: parseColor(ui.color.value),
            intensity: parseFloat(ui.intensity.value),
            castShadows: true
          });
          // Align to camera yaw/pitch
          e.setPosition(pivotYaw.getPosition());
          e.setRotation(pivotYaw.getRotation());
          app.root.addChild(e);
          createdLights.push(e);
          refreshLightList();
          saveStateDebounced();
        }

        function addPoint() {
          const e = new pc.Entity('PointLight');
          e.addComponent('light', {
            type: 'point',
            color: parseColor(ui.color.value),
            intensity: parseFloat(ui.intensity.value),
            range: 15
          });
          // Place in front of camera
          const pos = pivotYaw.getPosition().clone();
          const fwd = pivotYaw.forward.clone(); fwd.y = 0; fwd.normalize();
          pos.add(fwd.scale(2));
          e.setPosition(pos);
          app.root.addChild(e);
          createdLights.push(e);
          refreshLightList();
          saveStateDebounced();
        }

        function clearLights() {
          createdLights.forEach(l => l.destroy());
          createdLights.length = 0;
          refreshLightList();
          saveStateDebounced();
        }

        ui.btnAmbient.addEventListener('click', addAmbient);
        ui.btnDirectional.addEventListener('click', addDirectional);
        ui.btnPoint.addEventListener('click', addPoint);
        ui.btnClear.addEventListener('click', clearLights);

        // Light selection and transform controls
        let lightsAll = [];
        function collectAllLights() {
          // include default light + created
          lightsAll = [];
          app.root.findComponents('light').forEach(comp => {
            if (comp && comp.entity?.enabled) lightsAll.push(comp.entity);
          });
        }

        function refreshLightList() {
          collectAllLights();
          ui.lightList.innerHTML = '';
          lightsAll.forEach((ent, idx) => {
            const opt = document.createElement('option');
            opt.value = String(idx);
            opt.textContent = `${ent.name || 'Light'} (${ent.light.type})`;
            ui.lightList.appendChild(opt);
          });
          if (lightsAll.length > 0) {
            ui.lightList.value = '0';
            updateSlidersFromSelected();
          }
        }

        function getSelectedLight() {
          const idx = parseInt(ui.lightList.value || '0', 10);
          return lightsAll[idx];
        }

        function updateSlidersFromSelected() {
          const ent = getSelectedLight();
          if (!ent) return;
          const p = ent.getPosition();
          ui.posX.value = p.x.toFixed(2);
          ui.posY.value = p.y.toFixed(2);
          ui.posZ.value = p.z.toFixed(2);
        }

        function applySliderToSelected() {
          const ent = getSelectedLight();
          if (!ent) return;
          const x = parseFloat(ui.posX.value);
          const y = parseFloat(ui.posY.value);
          const z = parseFloat(ui.posZ.value);
          ent.setLocalPosition(x, y, z);
          saveStateDebounced();
        }

        ui.lightList.addEventListener('change', updateSlidersFromSelected);
        ui.posX.addEventListener('input', applySliderToSelected);
        ui.posY.addEventListener('input', applySliderToSelected);
        ui.posZ.addEventListener('input', applySliderToSelected);

        // JSON DB (localStorage) and import/export
        const STATE_KEY = 'pc_vr_scene_state_v1';

        function colorToHex(c) {
          const r = Math.round(pc.math.clamp(c.r, 0, 1) * 255).toString(16).padStart(2, '0');
          const g = Math.round(pc.math.clamp(c.g, 0, 1) * 255).toString(16).padStart(2, '0');
          const b = Math.round(pc.math.clamp(c.b, 0, 1) * 255).toString(16).padStart(2, '0');
          return `#${r}${g}${b}`;
        }

        function getState() {
          collectAllLights();
          const lightsState = lightsAll.map(ent => ({
            name: ent.name,
            type: ent.light.type,
            color: colorToHex(ent.light.color),
            intensity: ent.light.intensity,
            castShadows: !!ent.light.castShadows,
            range: ent.light.range ?? null,
            pos: ent.getPosition().toArray(),
            rotEuler: ent.getLocalEulerAngles().toArray()
          }));
          const cameraState = {
            pos: pivotYaw.getPosition().toArray(),
            lookX, lookY
          };
          const museumEnt = app.root.findByName('Museum');
          const museumState = museumEnt ? {
            pos: museumEnt.getPosition().toArray(),
            scale: museumEnt.getLocalScale().toArray()
          } : null;
          return { lightsState, cameraState, museumState };
        }

        function applyState(state) {
          if (!state) return;
          // Clear created lights first
          clearLights();
          // Update or recreate lights
          const defaultLight = app.root.findByName('Light');
          state.lightsState?.forEach((ls, idx) => {
            let ent = null;
            if (defaultLight && idx === 0 && defaultLight.light.type === ls.type) {
              ent = defaultLight;
            }
            if (!ent) {
              ent = new pc.Entity(ls.name || 'Light');
              ent.addComponent('light', { type: ls.type });
              app.root.addChild(ent);
              if (ent !== defaultLight) createdLights.push(ent);
            }
            ent.light.color = pc.Color.fromString(ls.color || '#ffffff');
            ent.light.intensity = ls.intensity ?? 1;
            ent.light.castShadows = !!ls.castShadows;
            if (ent.light.type === 'point' && ls.range != null) ent.light.range = ls.range;
            ent.setLocalPosition(new pc.Vec3().fromArray(ls.pos || [0,2,0]));
            if (ls.rotEuler) ent.setLocalEulerAngles(new pc.Vec3().fromArray(ls.rotEuler));
          });

          if (state.cameraState) {
            pivotYaw.setLocalPosition(new pc.Vec3().fromArray(state.cameraState.pos || [0,1.65,4]));
            lookX = state.cameraState.lookX ?? lookX;
            lookY = state.cameraState.lookY ?? lookY;
            pivotYaw.setLocalEulerAngles(0, lookY, 0);
            pivotPitch.setLocalEulerAngles(lookX, 0, 0);
          }

          if (state.museumState) {
            const m = app.root.findByName('Museum');
            if (m) {
              m.setLocalPosition(new pc.Vec3().fromArray(state.museumState.pos || [0,0,0]));
              m.setLocalScale(new pc.Vec3().fromArray(state.museumState.scale || [1,1,1]));
            }
          }

          refreshLightList();
        }

        function saveState() {
          const state = getState();
          localStorage.setItem(STATE_KEY, JSON.stringify(state));
        }
        let saveTimer = null;
        function saveStateDebounced() {
          clearTimeout(saveTimer);
          saveTimer = setTimeout(saveState, 300);
        }
        function loadState() {
          try {
            const raw = localStorage.getItem(STATE_KEY);
            if (!raw) return;
            const state = JSON.parse(raw);
            applyState(state);
          } catch (e) { console.warn('Failed to load state', e); }
        }

        ui.btnSave.addEventListener('click', () => { saveState(); });
        ui.btnLoad.addEventListener('click', () => { loadState(); });
        ui.btnExport.addEventListener('click', () => {
          const blob = new Blob([JSON.stringify(getState(), null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = 'scene-state.json'; a.click();
          URL.revokeObjectURL(url);
        });
        ui.btnImport.addEventListener('click', () => ui.importFile.click());
        ui.importFile.addEventListener('change', (e) => {
          const file = e.target.files?.[0]; if (!file) return;
          const reader = new FileReader();
          reader.onload = () => {
            try { const state = JSON.parse(reader.result); applyState(state); saveState(); }
            catch (err) { console.warn('Invalid JSON', err); }
          };
          reader.readAsText(file);
          e.target.value = '';
        });

        // Cardboard stereo mode (dual cameras)
        let cardboardEnabled = false;
        let camLeft = null, camRight = null;
        function enableCardboard() {
          if (cardboardEnabled) return;
          camera.enabled = false;
          const mkCam = (name, rect, xOffset) => {
            const e = new pc.Entity(name);
            e.addComponent('camera', { clearColor: new pc.Color(0.88,0.93,1) });
            e.camera.fov = 90; // Daydream-like FOV
            e.camera.rect = rect; // [x, y, w, h]
            pivotPitch.addChild(e);
            e.setLocalPosition(xOffset, 0, 0);
            return e;
          };
          camLeft = mkCam('CamLeft', new pc.Vec4(0, 0, 0.5, 1), -0.032);
          camRight = mkCam('CamRight', new pc.Vec4(0.5, 0, 0.5, 1), 0.032);
          // show lens vignette overlay
          lensMask.style.display = 'block';
          ui.btnCardboard.textContent = 'Disable Cardboard';
          cardboardEnabled = true;
          // try fullscreen on Cardboard for immersive view
          enterFullscreen();
          // hide note while in Cardboard
          document.getElementById('note')?.setAttribute('style','display:none');
        }
        function disableCardboard() {
          if (!cardboardEnabled) return;
          camLeft?.destroy(); camRight?.destroy();
          camLeft = null; camRight = null;
          camera.enabled = true;
          ui.btnCardboard.textContent = 'Enable Cardboard';
          cardboardEnabled = false;
          // show note back
          document.getElementById('note')?.setAttribute('style','');
          lensMask.style.display = 'none';
        }
        ui.btnCardboard.addEventListener('click', () => {
          if (app.xr && app.xr.active) return; // ignore in VR
          if (!cardboardEnabled) enableCardboard(); else disableCardboard();
        });

        // Auto-disable Cardboard when entering XR
        app.xr.on('start', () => { if (cardboardEnabled) disableCardboard(); });

        // Initial UI state
        refreshLightList();
        loadState();

        // Ground
        const ground = new pc.Entity('Ground');
        ground.addComponent('render', { type: 'plane', material: new pc.StandardMaterial() });
        ground.setLocalScale(50, 1, 50);
        ground.setLocalEulerAngles(-90, 0, 0);
        app.root.addChild(ground);
        ground.render.meshInstances[0].material.diffuse = new pc.Color(0.33, 0.8, 0.65);
        ground.render.meshInstances[0].material.update();

        // Box target in front
        const box = new pc.Entity('Box');
        box.addComponent('render', { type: 'box' });
        box.setLocalPosition(0, 1.25, 0);
        app.root.addChild(box);

        app.assets.loadFromUrl('./museum.glb', 'container', (err, asset) => {
          if (err) { console.warn('Failed to load museum.glb', err); return; }
          const museum = asset.resource.instantiateRenderEntity();
          museum.name = 'Museum';
          museum.setLocalPosition(0, 0, 0);
          museum.setLocalScale(1, 1, 1);
          app.root.addChild(museum);
        });

        // Controller visual helpers
        const controllers = [];
        function createController(colorHex) {
          const e = new pc.Entity('Controller');
          e.addComponent('render', { type: 'capsule' });
          e.setLocalScale(0.03, 0.15, 0.03);
          const m = new pc.StandardMaterial();
          m.diffuse = pc.Color.fromString(colorHex);
          m.update();
          e.render.meshInstances.forEach(mi => mi.material = m);
          app.root.addChild(e);
          return e;
        }

        // Input feedback: pulse box color on select
        function pulse(entity, color, duration = 0.1) {
          const mat = entity.render ? entity.render.meshInstances[0].material : null;
          if (!mat) return;
          const original = mat.diffuse.clone();
          mat.diffuse.copy(color); mat.update();
          setTimeout(() => { mat.diffuse.copy(original); mat.update(); }, duration * 1000);
        }

        // XR setup
        const vrBtn = document.getElementById('vrBtn');
        const vrFab = document.getElementById('vrFab');
        const lensMask = document.getElementById('lensMask');
        let xrSupported = false;
        function isMobile() {
          return /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent);
        }
        async function enterFullscreen() {
          const el = document.documentElement;
          try {
            if (el.requestFullscreen) await el.requestFullscreen();
            else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
            else if (el.msRequestFullscreen) await el.msRequestFullscreen();
          } catch (_) { /* ignore */ }
          try { await screen.orientation?.lock?.('landscape'); } catch (_) { /* iOS Safari won't allow */ }
        }
        function updateVrButtonVisibility() {
          const active = !!(app.xr && app.xr.active) || !!cardboardEnabled;
          const show = xrSupported || isMobile();
          // Panel button
          vrBtn.hidden = !show && !active; // show if show==true; hide if not show and not active
          vrBtn.disabled = false;
          vrBtn.textContent = active ? 'Exit' : (xrSupported ? 'Enter VR' : 'Enter Cardboard');
          // Floating button (A-Frame-like)
          if (active || show) {
            vrFab.style.display = 'block';
            vrFab.textContent = active ? 'Exit' : (xrSupported ? 'VR' : 'Card');
            vrFab.title = active ? 'Exit' : (xrSupported ? 'Enter VR' : 'Enter Cardboard');
          } else {
            vrFab.style.display = 'none';
          }
        }

        async function enterVr() {
          try {
            await app.xr.start(pc.XRTYPE_VR, pc.XRSPACE_LOCAL);
          } catch (e) {
            console.warn('Failed to start VR', e);
          } finally {
            updateVrButtonVisibility();
          }
        }

        async function handleVrToggle() {
          // ensure fullscreen at user gesture
          await enterFullscreen();
          if (xrSupported) {
            if (app.xr && app.xr.active) {
              try { await app.xr.end(); } catch (e) { console.warn('Failed to end XR', e); }
            } else {
              await enterVr();
            }
          } else {
            if (!cardboardEnabled) enableCardboard(); else disableCardboard();
            updateVrButtonVisibility();
          }
        }
        vrBtn.addEventListener('click', handleVrToggle);
        vrFab.addEventListener('click', handleVrToggle);

        // XR events
        app.xr.on('start', () => {
          updateVrButtonVisibility();
          enterFullscreen();
          autoWalk = isMobile(); // enable auto-walk by default on mobile in XR
          // hide note in XR
          document.getElementById('note')?.setAttribute('style','display:none');
          // disable gyro while in XR
          if (gyroEnabled) {
            window.removeEventListener('deviceorientation', handleOrientation);
            gyroEnabled = false;
          }
          // Create visuals for hands/controllers if input is available
          controllers.length = 0;
          const input = app.xr.input;
          ['left', 'right'].forEach((handedness, i) => {
            const c = createController(i === 0 ? '#10b981' : '#3b82f6');
            controllers.push({ handedness, entity: c });
          });
        });

        app.xr.on('end', () => {
          updateVrButtonVisibility();
          controllers.forEach(c => c.entity.destroy());
          controllers.length = 0;
          // re-enable gyro after XR ends
          gyroBase = null; // reset reference
          enableGyroLookIfPossible();
          autoWalk = false;
          // show note back
          document.getElementById('note')?.setAttribute('style','');
        });

        // Per-frame update controller poses and auto-walk
        let autoWalk = false;
        app.on('update', dt => {
          // smooth look to reduce motion sickness
          const k = 0.18; // smoothing factor per frame
          lookY += (targetLookY - lookY) * k;
          lookX += (targetLookX - lookX) * k;
          pivotYaw.setLocalEulerAngles(0, lookY, 0);
          pivotPitch.setLocalEulerAngles(lookX, 0, 0);
          if (app.xr && app.xr.active) {
            const input = app.xr.input;
            controllers.forEach(c => {
              const source = input && input[c.handedness];
              if (source && source.grip) {
                c.entity.enabled = true;
                c.entity.setPosition(source.grip.getPosition());
                c.entity.setRotation(source.grip.getRotation());
              } else {
                c.entity.enabled = false;
              }
            });
            // Auto-walk in XR
            if (autoWalk) {
              const forward = pivotYaw.forward.clone(); forward.y = 0; forward.normalize();
              const move = forward.scale(1.6 * dt);
              pivotYaw.translate(move);
            }
          } else {
            const forward = pivotYaw.forward.clone(); forward.y = 0; forward.normalize();
            const right = pivotYaw.right.clone(); right.y = 0; right.normalize();
            const move = new pc.Vec3(0,0,0);
            if (keys['KeyW']) move.add(forward);
            if (keys['KeyS']) move.sub(forward);
            if (keys['KeyA']) move.sub(right);
            if (keys['KeyD']) move.add(right);
            if (autoWalk) move.add(forward.scale(0.8));
            if (move.lengthSq() > 0) {
              move.normalize().scale(moveSpeed * dt);
              pivotYaw.translate(move);
            }
          }
        });

        // Input events
        app.on('xr:input:selectstart', (inputSource) => {
          pulse(box, new pc.Color(1, 0.4, 0.4));
        });
        app.on('xr:input:squeezestart', (inputSource) => {
          pulse(box, new pc.Color(0.4, 1, 0.6));
        });

        // Hook PlayCanvas XR input events
        if (app.xr && app.xr.input) {
          app.xr.input.on('selectstart', (src) => app.fire('xr:input:selectstart', src));
          app.xr.input.on('squeezestart', (src) => app.fire('xr:input:squeezestart', src));
        } else {
          // If not ready yet, defer until XR starts
          app.xr?.on('start', () => {
            app.xr.input.on('selectstart', (src) => app.fire('xr:input:selectstart', src));
            app.xr.input.on('squeezestart', (src) => app.fire('xr:input:squeezestart', src));
          });
        }

        // Tick
        app.start();

        // Check support and show button
        if ('xr' in navigator) {
          navigator.xr.isSessionSupported('immersive-vr')
            .then((supported) => { xrSupported = !!supported; updateVrButtonVisibility(); })
            .catch(() => { xrSupported = false; updateVrButtonVisibility(); });
        } else {
          xrSupported = false;
          updateVrButtonVisibility();
        }

        if (isMobile()) {
          if (!cardboardEnabled && !(app.xr && app.xr.active)) {
            enableCardboard();
            updateVrButtonVisibility();
          }
          // Initialize gyro; if iOS requires gesture, fallback to one-time prompt
          enableGyroLookIfPossible();
          if (!gyroEnabled) {
            const once = async () => {
              window.removeEventListener('touchend', once);
              window.removeEventListener('click', once);
              await enableGyroLookIfPossible();
              await enterFullscreen();
            };
            window.addEventListener('touchend', once, { once: true });
            window.addEventListener('click', once, { once: true });
          }
        }
      })();
    </script>
  </body>
</html>
